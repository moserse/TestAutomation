/* Copyright 2001-2004 Roger Dingledine.
 * Copyright (c) 2004-2006, Roger Dingledine, Nick Mathewson.
 * Copyright (c) 2007-2015, The Tor Project, Inc. */
/* See LICENSE for licensing information */

/** String describing which Tor Git repository version the source was
 * built from.  This string is generated by a bit of shell kludging in
 * src/or/include.am, and is usually right.
 */
#include <stdio.h>
#include "util.h"
const char tor_git_revision[] =
#ifndef _MSC_VER
#include "micro-revision.i"
#endif
  "";

/**
 * \file tor_main.c
 * \brief Stub module containing a main() function. Allows unit
 * test binary to link against main.c.
 **/

int tor_main(int argc, char *argv[]);

/** We keep main() in a separate file so that our unit tests can use
 * functions from main.c)
 */
int
main(int argc, char *argv[])
{
  
  int driver;
  if (argc>=2){
    driver = atoi(argv[1]);
    switch(driver){
    case 1:
      if (argc >3){
	int ia=atoi(argv[2]);
	int ib=atoi(argv[3]);
	int answer;
	
	answer = round_to_next_multiple_of(ia,ib);
	
	chdir("./temp");
	FILE *file;
	file = fopen("./TestCase1.txt", "w");
	fprintf(file, "%i", answer);
	fclose(file);
      }
      else
	printf("there are not enough arguments to process this command");
      break;
      
      /* case 2: */
      /*   if (argc>3){ */
      /* 	char in[MAX] = (argv[2]);  */
      /* 	int n = atoi(argv[3]); */
      /* 	printf("%s\n",s); */
      /* 	printf("%i\n",n); */
      
      /* 	char *answer =""; */
      
      /* 	if (n ==0){ */
      /* 	  answer="error\n"; */
      /* 	} */
      /* 	else if(n>0){ */
      /* 	  *answer = tor_strndup_(in,1); */
      /* 	  printf("this should output %s",answer); */
      
      /* 	} */
      /* 	printf("%i is the int\n", n); */
      /* 	//printf("%S is the answer",answer); */
      /* 	chdir("./temp"); */
      /* 	FILE *file; */
      /* 	file = fopen("./TestCase2.txt", "w"); */
      /* 	fprintf(file, "%s", answer); */
      /* 	fclose(file); */
      /*   } */
      /*   else  */
      /* 	printf("there are not enough arguments included"); */
      /*   break; */
      
    case 3:
      if (argc >2){
	long long ia=atol(argv[2]);
	long long answer;
	
	answer = round_to_power_of_2(ia);
	
	chdir("./temp");
	FILE *file;
	file = fopen("./TestCase3.txt", "w");
	fprintf(file, "%lld", answer);
	fclose(file);
      }
      else
	printf("there are not enough arguments to process this command");
      break;
 
    case 4:
      if (argc >2){
	char a = argv[2][0];
	int answer;
	answer = digit_to_num(a);
	
	chdir("./temp");
	FILE *file;
	file = fopen("./TestCase4.txt", "w");
	fprintf(file, "%i", answer);
	fclose(file);
      }
      else
	printf("there are not enough arguments to process this command");
      break;

    case 5:
      if (argc >2){
	char* a = argv[2];
	int answer;
	answer = tor_strisnonupper(a);
	
	chdir("./temp");
	FILE *file;
	file = fopen("./TestCase5.txt", "w");
	fprintf(file, "%i", answer);
	fclose(file);
      }
      else
	printf("there are not enough arguments to process this command");
      break;

case 6:
      if (argc >2){
	uint32_t ia = ((uint32_t)strtol(argv[2], NULL, 0));
	uint32_t answer;
	answer = addr_mask_get_bits(ia);
	
	
	chdir("./temp");
	FILE *file;
	file = fopen("./TestCase6.txt", "w");
	fprintf(file, "%i", answer);
	fclose(file);
      }
      else
	printf("there are not enough arguments to process this command");
      break;

    case 7:
      if(argc>2){
	double da = atof(argv[2]);
	int answer;
	answer = tor_llround(da);
	
	chdir("./temp");
	FILE *file;
	file = fopen("./TestCase7.txt", "w");
	fprintf(file, "%i", answer);
	fclose(file);
      }
      else
	printf("there are not enough arguments to process this command");
      break;
	

    default:
      printf("There hasnt been a matching driver implemented yet\n");
      return ("X");
	break;
      
      return 1;
      //else
      //return r;
    }
  }
  else
    printf("you have 0 arguments, thus are not testing");
}
